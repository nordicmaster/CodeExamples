В С/С++ любая сущность, объявленная, но не определённая в пределах компилируемого файла считается внешней. Это относится и к функциям в не меньшей степени, к чем к переменным. Ссылки на внешние функции остаются в скомпилированном объектном файле и будут заменены на обращения к настоящим сущностям только на этапе линковки, если все межмодульные зависимости будут удовлетворены. Не существует никакой разницы между PrivetVasya() и printf() — с точки зрения компилятора обе абсолютно равнозначны и про обе можно сказать «да это просто какие-то внешние функции». Когда идиотские учебники или учителя-недоучки начинают говорить «встроенная функция языка printf()» (а это очень популярный бред) — надо понимать, что это просто глупость, что в язык ничего такого не встроено, что компилятор обрабатывает вызов к printf() на тех же условиях, что и вызов к любой другой функции, да хоть в соседнем файле реализованной. Что касается той же printf() — то это не встроенная функция языка, а функция стандартной библиотеки языка. Стандарт на язык эту функцию описывает, провозглашает её наличие в стандартной библиотеке, но сам компилятор к стандартной библиотеке отношения не имеет — она может появиться на этапе линковки, а может и вообще не появляться.

Тем не менее, есть поистине встроенные функции, для которых в компиляторе на самом деле реализована особая обработка — они называются intrinsic-ами. У разных компиляторов набор intrinsic-ов разный. Intrinsic-ом может быть и функция, которая штатно должна жить в стандартной библиотеке. При вызове intrinsic-функции компилятор генерирует особый код, характерный именно для данной функции: не генерируется никакого call-а, не будет никакого реального вызова и возврата, а будет несколько инструкций, выполняющих нужную задачу. Например очень распространённый intrinsic memcpy() компилируется не в вызов какой-то функции, а в инструкцию repnz movs (пример для x86).

Понятное дело, что в стандартной библиотеке С (libc) для AVR есть некоторые функции, которые обеспечивают задержку. Естественно, это полновесные функции, которые внутри крутят цикл. Если нужна задержка в 1—2 такта, то естественно, такие тяжеловесные функции не подходят. Сделать задержку в 1 такт полноценной (и обыкновенной) функцией нельзя: даже если это будет совершенно пустая функция, инструкция call выполняется за 4 такта, и инструкция ret — ещё 4 такта, итого 8 тактов на вызов пустой функции.

Без малейшей лишней мысли понятно, что задержки в единицы тактов (меньше 8) могут быть реализованы только intrinsic-ами. И теперь, скрестив пальцы, спросим: а есть ли в avr-gcc delay-функции (функции задержки), выполненные как intrinsic-и? Действительно есть такой intrinsic — функция называется __builtin_avr_delay_cycles().
